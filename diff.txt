diff --git a/bots/tg_bot/handlers/router.py b/bots/tg_bot/handlers/router.py
index 2894780..b33de98 100644
--- a/bots/tg_bot/handlers/router.py
+++ b/bots/tg_bot/handlers/router.py
@@ -107,22 +107,21 @@ async def add_account_id(call: types.CallbackQuery, state: FSMContext, tclient:
 
         if need_candles:
             async def _guarded(uid: str):
-                logger.debug("fetching %s", uid)
+                logger.debug("fetching", extra={"uid": uid})
                 await _fetch(uid)
 
             result = await asyncio.gather(*[_guarded(uid) for uid in need_candles],
                                           return_exceptions=True)
             for r in result:
                 if isinstance(r, Exception):
-                    logger.error("fetching error: %s", r)
+                    logger.error("fetching error", extra={"Exception": r})
 
-        logger.debug("need_candles: %s", len(need_candles))
+        logger.debug("Need count candles update", extra={"need_candles": need_candles})
         # 5) считаем индикаторы и готовим батч для upsert
         rows_for_upsert = []
         instruments_for_message = []  # чтобы красиво отправить пользователю
 
         now_utc = datetime.now(timezone.utc)
-        logger.debug("now_utc: %s", now_utc)
         for uid in instruments_ids:
             meta = instruments_meta[uid]
             existing = existing_by_id.get(uid)
diff --git a/clients/tinkoff/client.py b/clients/tinkoff/client.py
index 719a536..631b861 100644
--- a/clients/tinkoff/client.py
+++ b/clients/tinkoff/client.py
@@ -62,19 +62,19 @@ class TClient:
 
     @require_api
     async def get_accounts(self) -> list[ti.Account]:
-        self.logger.debug('Getting accounts')
+        self.logger.info('Getting accounts')
         get_accounts_response = await self._api.users.get_accounts()
         return get_accounts_response.accounts
 
     @require_api
     async def get_portfolio(self, account_id) -> ti.PortfolioResponse:
-        self.logger.debug('Getting portfolio')
+        self.logger.info('Getting portfolio')
         portfolio_response = await self._api.operations.get_portfolio(account_id=account_id)
         return portfolio_response
 
     @require_api
     async def _get_favorites_groups(self) -> list[FavoriteGroup]:
-        self.logger.debug('Getting favorite groups')
+        self.logger.info('Getting favorite groups')
         response = await self._api.instruments.get_favorite_groups(
             request=GetFavoriteGroupsRequest()
         )
@@ -82,7 +82,7 @@ class TClient:
 
     @require_api
     async def get_favorites_instruments(self) -> list[ti.GetFavoritesResponse]:
-        self.logger.debug('Getting favorites')
+        self.logger.info('Getting favorites instruments')
         groups = []
         response_groups = await self._get_favorites_groups()
         for group in response_groups:
@@ -100,19 +100,22 @@ class TClient:
                            interval: ti.CandleInterval,
                            start: datetime.datetime,
                            end: datetime.datetime) -> ti.GetCandlesResponse:
-        self.logger.debug('Getting candles_resp %s', instrument_id)
+        self.logger.info('Getting candles_resp',
+                         extra={'instrument_id': instrument_id, 'interval': interval, 'start': start, 'end': end})
         candles_response = await self._api.market_data.get_candles(
             instrument_id=instrument_id,
             interval=interval,
             from_=start,
             to=end
         )
-        self.logger.debug('Count Candles: %s', len(candles_response.candles))
+        self.logger.info('Count Candles',
+                         extra={'count': candles_response.count, 'instrument_id': instrument_id, 'interval': interval,
+                                'start': start, 'end': end})
         return candles_response
 
     @require_api
     async def get_days_candles_for_2_months(self, instrument_id: str) -> ti.GetCandlesResponse:
-        self.logger.debug('Getting days candles_resp for 2 months, %s', instrument_id)
+        self.logger.info('Getting days candles_resp for 2 months', extra={'instrument_id': instrument_id})
 
         now = dt.now(datetime.timezone.utc)
         response = await self._get_candles(
@@ -125,7 +128,7 @@ class TClient:
 
     @require_api
     async def get_name_by_id(self, instrument_id: str) -> str:
-        self.logger.debug('Getting name by id: %s', instrument_id)
+        self.logger.info('Getting name by id', extra={'instrument_id': instrument_id})
         response = await self._api.instruments.get_instrument_by(
             id_type=ti.InstrumentIdType.INSTRUMENT_ID_TYPE_UID,
             id=instrument_id
@@ -137,14 +140,14 @@ class TClient:
         ti.GetFuturesMarginResponse
     ]:
         try:
-            self.logger.debug('Get min_price_increment amount for futures: %s',
-                              uid)
+            self.logger.info('Get min_price_increment amount for futures',
+                             extra={'uid': uid})
             margin_info = await self._api.instruments.get_futures_margin(
                 instrument_id=uid
             )
             return margin_info
         except AioRequestError:
-            self.logger.debug('Not futures instrument')
+            self.logger.info('Not futures instrument')
             return None
 
     async def start(self, accounts: list[str]) -> None:
@@ -219,28 +222,28 @@ class TClient:
                     if self.subscribes:
                         for key, value in self.subscribes.items():
                             if key == 'last_price':
-                                self.logger.debug("Subscribing to instrument_last_price %s",
-                                                  ", ".join(value))
+                                self.logger.info("Subscribing to instrument_last_price",
+                                                 extra={'instruments_id': ", ".join(value)})
                                 self.subscribe_to_instrument_last_price(*value)
 
                 async for response in self._stream_market:
                     if self._stream_bus is not None:
                         try:
-                            self.logger.debug("Put response MarketDS: %s",
-                                              response.__class__.__name__)
+                            self.logger.info("Put response MarketDS",
+                                             extra={"response": response.__class__.__name__})
                             await self._stream_bus.publish('market_data_stream', response)
                         except asyncio.QueueFull:
-                            self.logger.warning("Queue full, drop response %s",
-                                                response.__class__.__name__)
+                            self.logger.warning("Queue full, drop response",
+                                                extra={"response": response.__class__.__name__})
                     else:
-                        self.logger.debug("Received response: %s",
-                                          response.__class__.__name__)
+                        self.logger.info("Received response:",
+                                         extra={"response": response.__class__.__name__})
                 backoff = 1
 
             except asyncio.CancelledError:
                 raise
             except Exception as e:
-                self.logger.error("Stream MarketDS error: %s", e)
+                self.logger.error("Stream MarketDS error", extra={"exception": e})
                 try:
                     if self._stream_market is not None:
                         self._stream_market.stop()
@@ -253,29 +256,29 @@ class TClient:
         backoff = 1
         while self._api is not None:
             try:
-                self.logger.info("Start portfolio stream for accounts: %s",
-                                 ",".join(accounts))
+                self.logger.info("Start portfolio stream for accounts",
+                                 extra={"account_id": ",".join(accounts)})
                 async for response in self._api.operations_stream.portfolio_stream(
                         accounts=accounts,
 
                 ):
                     if self._stream_bus is not None:
                         try:
-                            self.logger.debug("Put Portfolio response: %s",
-                                              response.__class__.__name__)
+                            self.logger.debug("Put Portfolio response",
+                                              extra={"response": response.__class__.__name__})
                             await self._stream_bus.publish('portfolio_stream', response)
                         except asyncio.QueueFull:
-                            self.logger.warning("Queue full, drop response %s",
-                                                response.__class__.__name__)
+                            self.logger.warning("Queue full, drop response",
+                                                extra={"response": response.__class__.__name__})
                     else:
-                        self.logger.debug("Received Portfolio response: %s",
-                                          response.__class__.__name__)
+                        self.logger.debug("Received Portfolio response",
+                                          extra={"response": response.__class__.__name__})
                 backoff = 1
 
             except asyncio.CancelledError:
                 raise
             except Exception as e:
-                self.logger.error("Portfolio Stream error: %s", e)
+                self.logger.error("Portfolio Stream error", {"exception": e})
                 await asyncio.sleep(backoff)
                 backoff = min(backoff * 2, 60)
 
@@ -298,19 +301,21 @@ class TClient:
         response = await self._api.users.get_user_tariff()
         return response
 
-    def subscribe_to_instrument_last_price(self, *instrument_id: str) -> None:
-        self.logger.debug("Subscribing to instrument_last_price %s", ", ".join(instrument_id))
+    def subscribe_to_instrument_last_price(self, *instruments_id: str) -> None:
+        self.logger.debug("Subscribing to instrument_last_price",
+                          extra={"instruments_ids": ", ".join(instruments_id)})
         if self.subscribes.get('last_price'):
-            self.subscribes['last_price'].update(instrument_id)
+            self.subscribes['last_price'].update(instruments_id)
         else:
-            self.subscribes['last_price'] = set(instrument_id)
+            self.subscribes['last_price'] = set(instruments_id)
 
         self._stream_market.last_price.subscribe(
-            instruments=[ti.LastPriceInstrument(instrument_id=i) for i in instrument_id]
+            instruments=[ti.LastPriceInstrument(instrument_id=i) for i in instruments_id]
         )
 
     def unsubscribe_to_instrument_last_price(self, *instruments_id: str):
-        self.logger.debug("Unsubscribing to instrument_last_price %s", ", ".join(instruments_id))
+        self.logger.debug("Unsubscribing to instrument_last_price %s",
+                          extra={"instruments_ids": ", ".join(instruments_id)})
         for i_id in instruments_id:
             self.subscribes['last_price'].remove(i_id)
 
diff --git a/clients/tinkoff/name_service.py b/clients/tinkoff/name_service.py
index 02c0dcf..f48f1ba 100644
--- a/clients/tinkoff/name_service.py
+++ b/clients/tinkoff/name_service.py
@@ -22,15 +22,15 @@ class NameService:
         try:
             name = await self.redis_client.get_name(instrument_uid, self.cfg.namespace)
             if name:
-                self.log.debug("Got name %s from cache", name)
+                self.log.debug("Got name from cache", extra={"instrument_name": name})
                 return name
         except Exception as e:
-            self.log.error("Error while GETTING name from cache: %s", e)
+            self.log.error("Error while GETTING name from cache", extra={"exception": e})
 
         name = await self.tclient.get_name_by_id(instrument_uid)
         try:
             await self.redis_client.set_name(instrument_uid, name, self.cfg.ttl, self.cfg.namespace)
-            self.log.debug("Got name %s from Tinkoff API and put Redis", name)
+            self.log.debug("Got name from Tinkoff API and put Redis", extra={"instrument_name": name})
         except Exception as e:
-            self.log.error("Error while SETTING name to cache: %s", e)
+            self.log.error("Error while SETTING name to cache", extra={"exception": e})
         return name
diff --git a/core/domains/event_bus.py b/core/domains/event_bus.py
index 84682bd..a69638c 100644
--- a/core/domains/event_bus.py
+++ b/core/domains/event_bus.py
@@ -21,19 +21,19 @@ class StreamBus:
 
     async def publish(self, topic: str, data: Any) -> None:
         try:
-            self.log.debug(f"publish {topic} {data}")
+            self.log.debug(f"publish", extra={"data": data, "topic": topic})
             await self.q.put((topic, data))
         except asyncio.CancelledError:
             raise
 
     async def _loop(self) -> None:
-        self.log.debug("_loop_start, %s", not self._stop.is_set())
+        self.log.debug("_loop_start", extra={"is_stop": not self._stop.is_set()})
         while not self._stop.is_set():
             topic, data = await self.q.get()
-            self.log.debug(f"get {topic} {data}")
+            self.log.debug(f"get", extra={"data": data, "topic": topic})
             try:
                 for h in self._subs.get(topic, []):
-                    self.log.debug(f"Go handler {topic} {data} {h.__name__}")
+                    self.log.debug(f"Go handler", extra={"data": data, "h": h.__name__, "topic": topic})
                     # параллельно, но без потери исключений
                     await h(data)
             except Exception as e:
diff --git a/database/redis/client.py b/database/redis/client.py
index 006b33f..bb55b06 100644
--- a/database/redis/client.py
+++ b/database/redis/client.py
@@ -31,7 +31,7 @@ class RedisClient:
                 retry_on_timeout=self._cfg.retry_on_timeout
             )
             pong = await self._redis.ping()
-            self.log.info(f"Redis connected: {pong}")
+            self.log.info(f"Redis connected", extra={"pong": pong})
 
     async def close(self):
         if self._redis is not None:
diff --git a/main.py b/main.py
index 042ac59..879749d 100644
--- a/main.py
+++ b/main.py
@@ -143,8 +143,9 @@ class Service:
             now = datetime.now(self.tz)
             for i in instruments:
                 if not is_updated_today(i.last_update, now, self.tz):
-                    self.log.debug("Refresh indicators for %s",
-                                   await self.name_service.get_name(i.instrument_id))
+                    self.log.debug("Refresh indicators for",
+                                   extra={"instrument_name": await self.name_service.get_name(i.instrument_id),
+                                          "instrument_id": i.instrument_id})
                     tasks.append(self._recalc_and_update(i.instrument_id, update_notify, s))
             await asyncio.gather(*tasks, return_exceptions=True)
             await s.commit()
@@ -176,12 +177,14 @@ class Service:
                 await self.dp.start_polling(self.tg_bot)
                 backoff = 5  # если вышли «нормально», сброс
             except aiogram.exceptions.TelegramNetworkError as e:
-                self.log.warning("Polling network error: %s — retry in %ss", e, backoff)
+                self.log.warning("Polling network error: %s — retry in",
+                                 extra={"exception": e, "backoff": backoff})
                 await asyncio.sleep(backoff)
                 backoff = min(backoff * 2, 120)
                 continue
             except Exception as e:
-                self.log.exception("Polling crashed: %s — retry in %ss", e, backoff)
+                self.log.exception("Polling crashed: %s — retry in %ss",
+                                   extra={"exception": e, "backoff": backoff})
                 await asyncio.sleep(backoff)
                 backoff = min(backoff * 2, 120)
                 continue
diff --git a/utils/logger.py b/utils/logger.py
index 8645880..f1def1d 100644
--- a/utils/logger.py
+++ b/utils/logger.py
@@ -1,6 +1,60 @@
+import json
 import os
 import logging
 import logging.config
+from datetime import datetime, timezone
+
+
+class JsonFormatter(logging.Formatter):
+    """Форматтер, сериализующий LogRecord в JSON для Loki/Promtail."""
+    def formatTime(self, record, datefmt=None):
+        return datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat()
+
+    def format(self, record: logging.LogRecord) -> str:
+        # текст сообщения (учтёт %s, .format и т.д.)
+        message = record.getMessage()
+        payload = {
+            "ts": self.formatTime(record),     # UTC ISO-8601
+            "level": record.levelname,
+            "logger": record.name,
+            "module": record.module,
+            "line": record.lineno,
+            "msg": message,
+        }
+        # добавим поля из record.__dict__ (в т.ч. extra=...)
+        for k, v in record.__dict__.items():
+            if k in payload or k.startswith("_"):
+                continue
+            if k in (
+                "msg", "args", "levelno", "levelname", "name", "pathname",
+                "filename", "module", "exc_info", "exc_text", "stack_info",
+                "lineno", "funcName", "created", "msecs", "relativeCreated",
+                "thread", "threadName", "processName", "process"
+            ):
+                continue
+            payload[k] = v
+
+        if record.exc_info:
+            payload["exc_info"] = self.formatException(record.exc_info)
+
+        # default=str — чтобы внезапные объекты не ломали сериализацию
+        return json.dumps(payload, ensure_ascii=False, default=str)
+
+
+class ContextFilter(logging.Filter):
+    """
+    Универсальный фильтр: добавляет стабильные поля service/env
+    (низкая кардинальность — пригодно для labels в Loki).
+    """
+    def __init__(self, service: str | None = None, env: str | None = None):
+        super().__init__()
+        self.service = service or os.getenv("SERVICE_NAME", "trading-bot")
+        self.env = env or os.getenv("ENV", "prod")
+
+    def filter(self, record: logging.LogRecord) -> bool:
+        setattr(record, "service", self.service)
+        setattr(record, "env", self.env)
+        return True
 
 
 def setup_logging_from_dict(config: dict) -> None:
